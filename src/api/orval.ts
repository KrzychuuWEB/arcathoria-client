/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from "@tanstack/react-query";

import type {
    AccountDTO,
    AccountProblemDetail,
    AuthProblemDetail,
    AuthRequestDTO,
    CharacterDTO,
    CharacterProblemDetail,
    CombatIdDTO,
    CombatProblemDetail,
    CombatResultDTO,
    CreateCharacterDTO,
    CsrfParams,
    CsrfToken,
    ExecuteActionDTO,
    InitPveDTO,
    MonsterDTO,
    MonsterProblemDetail,
    RegisterDTO,
    SelectCharacterDTO,
} from "./orval.schemas";

import { api } from "./client";

/**
 * @summary Perform action in combat
 */
export const performActionInCombat = (
    id: string,
    executeActionDTO: ExecuteActionDTO,
    signal?: AbortSignal,
) => {
    return api<CombatResultDTO>({
        url: `/combats/${id}/actions/execute`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: executeActionDTO,
        signal,
    });
};

export const getPerformActionInCombatMutationOptions = <
    TError = CombatProblemDetail | CombatProblemDetail | CombatProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof performActionInCombat>>,
        TError,
        { id: string; data: ExecuteActionDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof performActionInCombat>>,
    TError,
    { id: string; data: ExecuteActionDTO },
    TContext
> => {
    const mutationKey = ["performActionInCombat"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof performActionInCombat>>,
        { id: string; data: ExecuteActionDTO }
    > = (props) => {
        const { id, data } = props ?? {};

        return performActionInCombat(id, data);
    };

    return { mutationFn, ...mutationOptions };
};

export type PerformActionInCombatMutationResult = NonNullable<
    Awaited<ReturnType<typeof performActionInCombat>>
>;
export type PerformActionInCombatMutationBody = ExecuteActionDTO;
export type PerformActionInCombatMutationError =
    | CombatProblemDetail
    | CombatProblemDetail
    | CombatProblemDetail;

/**
 * @summary Perform action in combat
 */
export const usePerformActionInCombat = <
    TError = CombatProblemDetail | CombatProblemDetail | CombatProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof performActionInCombat>>,
            TError,
            { id: string; data: ExecuteActionDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof performActionInCombat>>,
    TError,
    { id: string; data: ExecuteActionDTO },
    TContext
> => {
    const mutationOptions = getPerformActionInCombatMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Initial PVE combat
 */
export const initPveCombat = (initPveDTO: InitPveDTO, signal?: AbortSignal) => {
    return api<CombatResultDTO>({
        url: `/combats/init/pve`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: initPveDTO,
        signal,
    });
};

export const getInitPveCombatMutationOptions = <
    TError = CombatProblemDetail | CombatProblemDetail | CombatProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof initPveCombat>>,
        TError,
        { data: InitPveDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof initPveCombat>>,
    TError,
    { data: InitPveDTO },
    TContext
> => {
    const mutationKey = ["initPveCombat"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof initPveCombat>>,
        { data: InitPveDTO }
    > = (props) => {
        const { data } = props ?? {};

        return initPveCombat(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type InitPveCombatMutationResult = NonNullable<Awaited<ReturnType<typeof initPveCombat>>>;
export type InitPveCombatMutationBody = InitPveDTO;
export type InitPveCombatMutationError =
    | CombatProblemDetail
    | CombatProblemDetail
    | CombatProblemDetail;

/**
 * @summary Initial PVE combat
 */
export const useInitPveCombat = <
    TError = CombatProblemDetail | CombatProblemDetail | CombatProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof initPveCombat>>,
            TError,
            { data: InitPveDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof initPveCombat>>,
    TError,
    { data: InitPveDTO },
    TContext
> => {
    const mutationOptions = getInitPveCombatMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all characters
 */
export const listCharacters = (signal?: AbortSignal) => {
    return api<CharacterDTO[]>({ url: `/characters`, method: "GET", signal });
};

export const getListCharactersQueryKey = () => {
    return [`/characters`] as const;
};

export const getListCharactersQueryOptions = <
    TData = Awaited<ReturnType<typeof listCharacters>>,
    TError = CharacterProblemDetail,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCharacters>>, TError, TData>>;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getListCharactersQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCharacters>>> = ({ signal }) =>
        listCharacters(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof listCharacters>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListCharactersQueryResult = NonNullable<Awaited<ReturnType<typeof listCharacters>>>;
export type ListCharactersQueryError = CharacterProblemDetail;

export function useListCharacters<
    TData = Awaited<ReturnType<typeof listCharacters>>,
    TError = CharacterProblemDetail,
>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCharacters>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listCharacters>>,
                    TError,
                    Awaited<ReturnType<typeof listCharacters>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListCharacters<
    TData = Awaited<ReturnType<typeof listCharacters>>,
    TError = CharacterProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof listCharacters>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof listCharacters>>,
                    TError,
                    Awaited<ReturnType<typeof listCharacters>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListCharacters<
    TData = Awaited<ReturnType<typeof listCharacters>>,
    TError = CharacterProblemDetail,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCharacters>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all characters
 */

export function useListCharacters<
    TData = Awaited<ReturnType<typeof listCharacters>>,
    TError = CharacterProblemDetail,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listCharacters>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getListCharactersQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Create a new character
 */
export const createCharacter = (createCharacterDTO: CreateCharacterDTO, signal?: AbortSignal) => {
    return api<CharacterDTO>({
        url: `/characters`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: createCharacterDTO,
        signal,
    });
};

export const getCreateCharacterMutationOptions = <
    TError = CharacterProblemDetail | CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof createCharacter>>,
        TError,
        { data: CreateCharacterDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof createCharacter>>,
    TError,
    { data: CreateCharacterDTO },
    TContext
> => {
    const mutationKey = ["createCharacter"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof createCharacter>>,
        { data: CreateCharacterDTO }
    > = (props) => {
        const { data } = props ?? {};

        return createCharacter(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type CreateCharacterMutationResult = NonNullable<
    Awaited<ReturnType<typeof createCharacter>>
>;
export type CreateCharacterMutationBody = CreateCharacterDTO;
export type CreateCharacterMutationError =
    | CharacterProblemDetail
    | CharacterProblemDetail
    | CharacterProblemDetail;

/**
 * @summary Create a new character
 */
export const useCreateCharacter = <
    TError = CharacterProblemDetail | CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof createCharacter>>,
            TError,
            { data: CreateCharacterDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof createCharacter>>,
    TError,
    { data: CreateCharacterDTO },
    TContext
> => {
    const mutationOptions = getCreateCharacterMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Select character
 */
export const selectCharacter = (selectCharacterDTO: SelectCharacterDTO, signal?: AbortSignal) => {
    return api<CharacterDTO>({
        url: `/characters/selects`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: selectCharacterDTO,
        signal,
    });
};

export const getSelectCharacterMutationOptions = <
    TError = CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof selectCharacter>>,
        TError,
        { data: SelectCharacterDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof selectCharacter>>,
    TError,
    { data: SelectCharacterDTO },
    TContext
> => {
    const mutationKey = ["selectCharacter"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof selectCharacter>>,
        { data: SelectCharacterDTO }
    > = (props) => {
        const { data } = props ?? {};

        return selectCharacter(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type SelectCharacterMutationResult = NonNullable<
    Awaited<ReturnType<typeof selectCharacter>>
>;
export type SelectCharacterMutationBody = SelectCharacterDTO;
export type SelectCharacterMutationError = CharacterProblemDetail | CharacterProblemDetail;

/**
 * @summary Select character
 */
export const useSelectCharacter = <
    TError = CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof selectCharacter>>,
            TError,
            { data: SelectCharacterDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof selectCharacter>>,
    TError,
    { data: SelectCharacterDTO },
    TContext
> => {
    const mutationOptions = getSelectCharacterMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Remove selected character
 */
export const removeSelectedCharacter = () => {
    return api<void>({ url: `/characters/selects`, method: "DELETE" });
};

export const getRemoveSelectedCharacterMutationOptions = <
    TError = CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof removeSelectedCharacter>>,
        TError,
        void,
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof removeSelectedCharacter>>,
    TError,
    void,
    TContext
> => {
    const mutationKey = ["removeSelectedCharacter"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof removeSelectedCharacter>>,
        void
    > = () => {
        return removeSelectedCharacter();
    };

    return { mutationFn, ...mutationOptions };
};

export type RemoveSelectedCharacterMutationResult = NonNullable<
    Awaited<ReturnType<typeof removeSelectedCharacter>>
>;

export type RemoveSelectedCharacterMutationError = CharacterProblemDetail | CharacterProblemDetail;

/**
 * @summary Remove selected character
 */
export const useRemoveSelectedCharacter = <
    TError = CharacterProblemDetail | CharacterProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof removeSelectedCharacter>>,
            TError,
            void,
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof removeSelectedCharacter>>,
    TError,
    void,
    TContext
> => {
    const mutationOptions = getRemoveSelectedCharacterMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Login
 */
export const login = (authRequestDTO: AuthRequestDTO, signal?: AbortSignal) => {
    return api<void>({
        url: `/authenticate`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: authRequestDTO,
        signal,
    });
};

export const getLoginMutationOptions = <
    TError = AuthProblemDetail | AuthProblemDetail | AuthProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof login>>,
        TError,
        { data: AuthRequestDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: AuthRequestDTO },
    TContext
> => {
    const mutationKey = ["login"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof login>>,
        { data: AuthRequestDTO }
    > = (props) => {
        const { data } = props ?? {};

        return login(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = AuthRequestDTO;
export type LoginMutationError = AuthProblemDetail | AuthProblemDetail | AuthProblemDetail;

/**
 * @summary Login
 */
export const useLogin = <
    TError = AuthProblemDetail | AuthProblemDetail | AuthProblemDetail,
    TContext = unknown,
>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof login>>,
            TError,
            { data: AuthRequestDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: AuthRequestDTO },
    TContext
> => {
    const mutationOptions = getLoginMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Register new account
 */
export const register = (registerDTO: RegisterDTO, signal?: AbortSignal) => {
    return api<AccountDTO>({
        url: `/accounts/register`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: registerDTO,
        signal,
    });
};

export const getRegisterMutationOptions = <
    TError = AccountProblemDetail,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof register>>,
        TError,
        { data: RegisterDTO },
        TContext
    >;
}): UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterDTO },
    TContext
> => {
    const mutationKey = ["register"];
    const { mutation: mutationOptions } = options
        ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof register>>,
        { data: RegisterDTO }
    > = (props) => {
        const { data } = props ?? {};

        return register(data);
    };

    return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>;
export type RegisterMutationBody = RegisterDTO;
export type RegisterMutationError = AccountProblemDetail;

/**
 * @summary Register new account
 */
export const useRegister = <TError = AccountProblemDetail, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof register>>,
            TError,
            { data: RegisterDTO },
            TContext
        >;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterDTO },
    TContext
> => {
    const mutationOptions = getRegisterMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get monster by id
 */
export const getMonster = (id: string, signal?: AbortSignal) => {
    return api<MonsterDTO>({ url: `/monsters/${id}`, method: "GET", signal });
};

export const getGetMonsterQueryKey = (id?: string) => {
    return [`/monsters/${id}`] as const;
};

export const getGetMonsterQueryOptions = <
    TData = Awaited<ReturnType<typeof getMonster>>,
    TError = MonsterProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonster>>, TError, TData>>;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetMonsterQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonster>>> = ({ signal }) =>
        getMonster(id, signal);

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getMonster>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonsterQueryResult = NonNullable<Awaited<ReturnType<typeof getMonster>>>;
export type GetMonsterQueryError = MonsterProblemDetail;

export function useGetMonster<
    TData = Awaited<ReturnType<typeof getMonster>>,
    TError = MonsterProblemDetail,
>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonster>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getMonster>>,
                    TError,
                    Awaited<ReturnType<typeof getMonster>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonster<
    TData = Awaited<ReturnType<typeof getMonster>>,
    TError = MonsterProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonster>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getMonster>>,
                    TError,
                    Awaited<ReturnType<typeof getMonster>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonster<
    TData = Awaited<ReturnType<typeof getMonster>>,
    TError = MonsterProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonster>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get monster by id
 */

export function useGetMonster<
    TData = Awaited<ReturnType<typeof getMonster>>,
    TError = MonsterProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMonster>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetMonsterQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const csrf = (params: CsrfParams, signal?: AbortSignal) => {
    return api<CsrfToken>({ url: `/csrf`, method: "GET", params, signal });
};

export const getCsrfQueryKey = (params?: CsrfParams) => {
    return [`/csrf`, ...(params ? [params] : [])] as const;
};

export const getCsrfQueryOptions = <TData = Awaited<ReturnType<typeof csrf>>, TError = unknown>(
    params: CsrfParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrf>>, TError, TData>> },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getCsrfQueryKey(params);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof csrf>>> = ({ signal }) =>
        csrf(params, signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof csrf>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CsrfQueryResult = NonNullable<Awaited<ReturnType<typeof csrf>>>;
export type CsrfQueryError = unknown;

export function useCsrf<TData = Awaited<ReturnType<typeof csrf>>, TError = unknown>(
    params: CsrfParams,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrf>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof csrf>>,
                    TError,
                    Awaited<ReturnType<typeof csrf>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCsrf<TData = Awaited<ReturnType<typeof csrf>>, TError = unknown>(
    params: CsrfParams,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrf>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof csrf>>,
                    TError,
                    Awaited<ReturnType<typeof csrf>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCsrf<TData = Awaited<ReturnType<typeof csrf>>, TError = unknown>(
    params: CsrfParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrf>>, TError, TData>> },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useCsrf<TData = Awaited<ReturnType<typeof csrf>>, TError = unknown>(
    params: CsrfParams,
    options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof csrf>>, TError, TData>> },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getCsrfQueryOptions(params, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get combat by id
 */
export const getCombat = (id: string, signal?: AbortSignal) => {
    return api<CombatResultDTO>({ url: `/combats/${id}`, method: "GET", signal });
};

export const getGetCombatQueryKey = (id?: string) => {
    return [`/combats/${id}`] as const;
};

export const getGetCombatQueryOptions = <
    TData = Awaited<ReturnType<typeof getCombat>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCombat>>, TError, TData>>;
    },
) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetCombatQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCombat>>> = ({ signal }) =>
        getCombat(id, signal);

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getCombat>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCombatQueryResult = NonNullable<Awaited<ReturnType<typeof getCombat>>>;
export type GetCombatQueryError = CombatProblemDetail | CombatProblemDetail;

export function useGetCombat<
    TData = Awaited<ReturnType<typeof getCombat>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCombat>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCombat>>,
                    TError,
                    Awaited<ReturnType<typeof getCombat>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCombat<
    TData = Awaited<ReturnType<typeof getCombat>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCombat>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getCombat>>,
                    TError,
                    Awaited<ReturnType<typeof getCombat>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCombat<
    TData = Awaited<ReturnType<typeof getCombat>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCombat>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get combat by id
 */

export function useGetCombat<
    TData = Awaited<ReturnType<typeof getCombat>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCombat>>, TError, TData>>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetCombatQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get active combat by participant id
 */
export const getActiveCombatByParticipantId = (signal?: AbortSignal) => {
    return api<CombatIdDTO>({ url: `/combats/active`, method: "GET", signal });
};

export const getGetActiveCombatByParticipantIdQueryKey = () => {
    return [`/combats/active`] as const;
};

export const getGetActiveCombatByParticipantIdQueryOptions = <
    TData = Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof getActiveCombatByParticipantId>>, TError, TData>
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetActiveCombatByParticipantIdQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActiveCombatByParticipantId>>> = ({
        signal,
    }) => getActiveCombatByParticipantId(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActiveCombatByParticipantIdQueryResult = NonNullable<
    Awaited<ReturnType<typeof getActiveCombatByParticipantId>>
>;
export type GetActiveCombatByParticipantIdQueryError = CombatProblemDetail | CombatProblemDetail;

export function useGetActiveCombatByParticipantId<
    TData = Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    options: {
        query: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                TError,
                TData
            >
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                    TError,
                    Awaited<ReturnType<typeof getActiveCombatByParticipantId>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActiveCombatByParticipantId<
    TData = Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                TError,
                TData
            >
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                    TError,
                    Awaited<ReturnType<typeof getActiveCombatByParticipantId>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetActiveCombatByParticipantId<
    TData = Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get active combat by participant id
 */

export function useGetActiveCombatByParticipantId<
    TData = Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
    TError = CombatProblemDetail | CombatProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<
                Awaited<ReturnType<typeof getActiveCombatByParticipantId>>,
                TError,
                TData
            >
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetActiveCombatByParticipantIdQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

/**
 * @summary Get selected character
 */
export const getSelectedCharacter = (signal?: AbortSignal) => {
    return api<CharacterDTO>({ url: `/characters/selects/me`, method: "GET", signal });
};

export const getGetSelectedCharacterQueryKey = () => {
    return [`/characters/selects/me`] as const;
};

export const getGetSelectedCharacterQueryOptions = <
    TData = Awaited<ReturnType<typeof getSelectedCharacter>>,
    TError = CharacterProblemDetail | CharacterProblemDetail,
>(options?: {
    query?: Partial<
        UseQueryOptions<Awaited<ReturnType<typeof getSelectedCharacter>>, TError, TData>
    >;
}) => {
    const { query: queryOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getGetSelectedCharacterQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSelectedCharacter>>> = ({ signal }) =>
        getSelectedCharacter(signal);

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getSelectedCharacter>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSelectedCharacterQueryResult = NonNullable<
    Awaited<ReturnType<typeof getSelectedCharacter>>
>;
export type GetSelectedCharacterQueryError = CharacterProblemDetail | CharacterProblemDetail;

export function useGetSelectedCharacter<
    TData = Awaited<ReturnType<typeof getSelectedCharacter>>,
    TError = CharacterProblemDetail | CharacterProblemDetail,
>(
    options: {
        query: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSelectedCharacter>>, TError, TData>
        > &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSelectedCharacter>>,
                    TError,
                    Awaited<ReturnType<typeof getSelectedCharacter>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSelectedCharacter<
    TData = Awaited<ReturnType<typeof getSelectedCharacter>>,
    TError = CharacterProblemDetail | CharacterProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSelectedCharacter>>, TError, TData>
        > &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getSelectedCharacter>>,
                    TError,
                    Awaited<ReturnType<typeof getSelectedCharacter>>
                >,
                "initialData"
            >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSelectedCharacter<
    TData = Awaited<ReturnType<typeof getSelectedCharacter>>,
    TError = CharacterProblemDetail | CharacterProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSelectedCharacter>>, TError, TData>
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get selected character
 */

export function useGetSelectedCharacter<
    TData = Awaited<ReturnType<typeof getSelectedCharacter>>,
    TError = CharacterProblemDetail | CharacterProblemDetail,
>(
    options?: {
        query?: Partial<
            UseQueryOptions<Awaited<ReturnType<typeof getSelectedCharacter>>, TError, TData>
        >;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetSelectedCharacterQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}
